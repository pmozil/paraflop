#version 460
#extension GL_EXT_ray_tracing : require
#define MAX_RECURSION 4
#define SAMPLES 4
#define EPSILON 0.01F

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
} cam;

struct RayPayload {
	vec3 color;
    vec3 emission;
	float distance;
	vec3 normal;
	float reflector;
};

layout(location = 0) rayPayloadEXT RayPayload hitValue;

float random(vec2 st)
{
    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
}


void main()  {
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec4 origin = cam.viewInverse * vec4(0,0,0,1);
	vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1) ;
	vec4 direction = cam.viewInverse*vec4(normalize(target.xyz / target.w), 0) ;

	uint rayFlags = gl_RayFlagsOpaqueEXT;
	uint cullMask = 0xff;
	float tmin = 0.001;
	float tmax = 10000.0;

    vec3 color = vec3(0.0F);
    float reflection_coeff = 1.0F;
    vec3 tmp_orig = origin.xyz;
    vec3 tmp_dir = origin.xyz;
    vec3 tmp_dir_shift = vec3(0.0F);
    vec3 dir_shift = vec3(0.0F);
    bool trace = true;
    vec4 hitPos = vec4(0.0F);
    vec3 col = vec3(0.0F);

	for (int i = 0; i < MAX_RECURSION && trace; i++) {
        dir_shift = vec3(0.0F);
        for (int i = 0; i < SAMPLES; i++) {
            tmp_orig = origin.xyz;
            tmp_dir = direction.xyz;
		    traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, tmp_orig, tmin, tmp_dir, tmax, 0);

            col += hitValue.color * hitValue.emission * reflection_coeff;

		    if (hitValue.distance >= 0.0F) {
		    	hitPos = origin + direction * hitValue.distance;
                reflection_coeff *= hitValue.reflector;

		    	origin.xyz = hitPos.xyz + hitValue.normal * 0.001F;
		    	tmp_dir_shift = normalize(reflect(direction.xyz, hitValue.normal)) + normalize(vec3(
                        random(origin.xy),
                        random(origin.yz),
                        random(origin.zx))
                    ) * (1 - reflection_coeff);
                dir_shift += tmp_dir_shift;
                tmp_dir  += tmp_dir_shift;
		    } else {
                trace = false;
            }
        }
        color += col / SAMPLES;
        dir_shift /= SAMPLES;
		origin.xyz = hitPos.xyz + hitValue.normal * 0.001F;
        direction.xyz += dir_shift;
	}

    if (length(color) > EPSILON) {
	    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 0.0));
    } else {
	    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(0.0F, 0.0F, 0.2F, 0.0));
    }
}
